<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <title>P.R.O.P.H.E.T - Swing Predictor</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --bg-color: #ecf0f1;
            --text-color: #2c3e50;
            --border-color: #bdc3c7;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        /* --- Updated Header Style --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        h1 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.8em;
        }
        nav a {
            text-decoration: none;
            color: var(--secondary-color);
            font-weight: bold;
            margin-left: 15px;
        }
        nav a:hover {
            text-decoration: underline;
        }
        /* --- End Updated Header Style --- */
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }
        
        /* --- Styles for Auto-Suggest (Unchanged) --- */
        .autocomplete {
            position: relative;
            flex-grow: 1;
            min-width: 200px;
        }
        #symbolInput {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
        }
        #symbolInput:focus {
            border-color: var(--secondary-color);
            outline: none;
        }
        .autocomplete-items {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 4px;
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
            display: none; /* Hidden by default */
        }
        .autocomplete-items div {
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border-bottom: 1px solid #d4d4d4;
        }
        .autocomplete-items div:hover {
            background-color: #e9e9e9;
        }
        .autocomplete-active {
            background-color: var(--secondary-color) !important;
            color: #ffffff;
        }
        /* --- END: Styles for Auto-Suggest --- */

        #predictButton {
            padding: 8px 15px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }
        #predictButton:hover:not(:disabled) {
            background-color: #2980b9;
        }
        #predictButton:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        /* --- UPDATED COUNTDOWN TEXT --- */
        #countdown {
            font-weight: bold;
            color: var(--secondary-color);
            text-align: center;
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 4px;
            background-color: #e3f2fd;
        }
        /* --- END UPDATED COUNTDOWN TEXT --- */
        #results {
            margin-top: 20px;
        }
        .message {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .loading {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .prediction-section {
            margin-bottom: 20px;
        }
        .prediction-section h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .prediction-list {
            list-style: none;
            padding: 0;
        }
        .prediction-item {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 8px;
        }
        .prediction-item strong {
            color: var(--primary-color);
        }
        .timestamp {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }
        /* --- Rate Limit Warning --- */
        .rate-limit-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Updated Header with Navigation -->
        <header>
            <h1>üîÆ P.R.O.P.H.E.T - Market Swing Predictor</h1>
            <nav>
                <a href="index.html">Predictor</a>
                <a href="about.html">About</a>
            </nav>
        </header>

        <!-- Rate Limit Warning -->
        <div id="rateLimitWarning" class="rate-limit-warning">
            ‚ö†Ô∏è Rate limit exceeded. Please wait a moment before making another request.
        </div>

        <div class="controls">
            <!-- Auto-suggest input structure -->
            <div class="autocomplete">
                <input type="text" id="symbolInput" placeholder="Search for an asset (e.g., BTCUSDT)..." maxlength="20">
                <div id="symbolDropdown" class="autocomplete-items"></div>
            </div>
            <button id="predictButton" onclick="fetchPrediction()" disabled>Get Prediction</button>
        </div>

        <!-- UPDATED DEFAULT COUNTDOWN TEXT -->
        <div id="countdown">Next Prediction Update: Loading...</div>

        <div id="results"></div>
    </div>

    <script>
        // --- Configuration ---
        const API_BASE_URL = ""; // Use relative path if served by FastAPI

        let symbolsList = [];
        let countdownInterval;
        let requestCount = 0;
        const MAX_REQUESTS_PER_MINUTE = 8; // Conservative limit
        const REQUEST_RESET_TIME = 60000; // 1 minute

        // Reset request count every minute
        setInterval(() => {
            requestCount = 0;
        }, REQUEST_RESET_TIME);

        // --- Utility Functions ---
        function showResult(message, type = 'info') {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="message ${type}">${message}</div>`;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        function showRateLimitWarning() {
            const warningDiv = document.getElementById('rateLimitWarning');
            warningDiv.style.display = 'block';
            setTimeout(() => {
                warningDiv.style.display = 'none';
            }, 5000);
        }

        // --- Auto-Suggest Functions ---
        function initAutocomplete() {
            const input = document.getElementById("symbolInput");
            const dropdown = document.getElementById("symbolDropdown");

            input.oninput = function() {
                const val = this.value.toUpperCase();
                closeAllLists();
                if (!val) { return false; }
                let matches = 0;
                symbolsList.forEach(symbol => {
                    if (symbol.toUpperCase().includes(val) && matches < 10) {
                        matches++;
                        const item = document.createElement("DIV");
                        item.innerHTML = `<strong>${symbol.substr(0, val.length)}</strong>${symbol.substr(val.length)}`;
                        item.innerHTML += `<input type='hidden' value='${symbol}'>`;
                        item.addEventListener("click", function(e) {
                            input.value = this.getElementsByTagName("input")[0].value;
                            closeAllLists();
                            document.getElementById('predictButton').disabled = false;
                        });
                        dropdown.appendChild(item);
                    }
                });
                if (matches > 0) {
                    dropdown.style.display = 'block';
                }
            };

            input.onkeydown = function(e) {
                let items = document.getElementById("symbolDropdown").getElementsByTagName("div");
                if (e.keyCode == 40) { // Down arrow
                    e.preventDefault();
                    currentFocus++;
                    addActive(items);
                } else if (e.keyCode == 38) { // Up arrow
                    e.preventDefault();
                    currentFocus--;
                    addActive(items);
                } else if (e.keyCode == 13) { // Enter
                    e.preventDefault();
                    if (currentFocus > -1 && items) {
                        items[currentFocus].click();
                    } else if (symbolsList.includes(input.value.toUpperCase())) {
                         document.getElementById('predictButton').disabled = false;
                         document.getElementById('predictButton').click();
                    }
                }
            };

            function addActive(items) {
                if (!items) return false;
                removeActive(items);
                if (currentFocus >= items.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = (items.length - 1);
                items[currentFocus].classList.add("autocomplete-active");
            }
            function removeActive(items) {
                for (let i = 0; i < items.length; i++) {
                    items[i].classList.remove("autocomplete-active");
                }
            }
            function closeAllLists(elmnt) {
                const items = document.getElementsByClassName("autocomplete-items");
                for (let i = 0; i < items.length; i++) {
                    if (elmnt != items[i] && elmnt != input) {
                        items[i].style.display = 'none';
                    }
                }
                currentFocus = -1;
            }
            document.addEventListener("click", function (e) {
                closeAllLists(e.target);
            });
        }
        let currentFocus = -1;
        // --- END: Auto-Suggest Functions ---

        // --- Main Functions ---
        window.onload = async function() {
            try {
                showResult('Loading available assets...', 'loading');
                const response = await fetch(`${API_BASE_URL}/api/symbols`);
                if (!response.ok) {
                    if (response.status === 429) {
                        showRateLimitWarning();
                        throw new Error('Too many requests. Please try again later.');
                    }
                    const errorData = await response.text();
                    throw new Error(`Failed to load symbols (${response.status}): ${errorData}`);
                }
                symbolsList = await response.json();
                initAutocomplete();
                document.getElementById('predictButton').disabled = false;
                clearResults();
            } catch (error) {
                console.error("Error loading symbols:", error);
                showResult(`‚ùå Error loading symbols: ${error.message}`, 'error');
            }
            startCountdown();
        };

        async function fetchPrediction() {
            // Client-side rate limiting
            if (requestCount >= MAX_REQUESTS_PER_MINUTE) {
                showRateLimitWarning();
                return;
            }
            requestCount++;

            let symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
            if (!symbol) {
                showResult('‚ö†Ô∏è Please enter or select an asset.', 'error');
                return;
            }
            
            // Enhanced client-side validation
            const symbolRegex = /^[A-Z0-9]{3,20}$/;
            if (!symbolRegex.test(symbol)) {
                 showResult('‚ö†Ô∏è Please enter a valid asset symbol (e.g., BTCUSDT). Must be 3-20 alphanumeric characters.', 'error');
                 return;
            }

            showResult('üîç Fetching latest prediction...', 'loading');
            document.getElementById('predictButton').disabled = true;

            try {
                let response = await fetch(`${API_BASE_URL}/api/latest/${symbol}`);
                if (response.status === 404) {
                     showResult('‚öôÔ∏è Running market analysis (this may take 10-30 seconds)...', 'loading');
                     response = await fetch(`${API_BASE_URL}/api/predict/${symbol}`);
                }
                if (!response.ok) {
                    if (response.status === 429) {
                        showRateLimitWarning();
                        throw new Error('Too many requests. Please try again later.');
                    }
                    const errorData = await response.text();
                    throw new Error(`API request failed (${response.status}): ${errorData}`);
                }
                const data = await response.json();
                displayResults(data);
            } catch (error) {
                console.error("Prediction fetch error:", error);
                showResult(`‚ùå Error fetching prediction for ${symbol}: ${error.message}`, 'error');
            } finally {
                document.getElementById('predictButton').disabled = false;
            }
        }

        function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            
            const formatPriceLevel = function(price) {
                const numPrice = parseFloat(price);
                if (isNaN(numPrice)) return 'N/A';
                return numPrice.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 10,
                    useGrouping: false
                });
            };

            if (data.status && (data.status.includes("success") || data.status.includes("cache"))) {
                const predictions = data.predictions;
                const symbol = data.symbol;
                
                let html = `<h2>Predictions for ${symbol}</h2>`;
                if (predictions.timestamp_utc) {
                    const dateObj = new Date(predictions.timestamp_utc);
                    const formattedDate = dateObj.toLocaleString(undefined, {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        timeZoneName: 'short'
                    });
                    html += `<p class="timestamp"><strong>üïí Generated:</strong> ${formattedDate}</p>`;
                }
                
                html += `<div class="prediction-section">`;
                html += `<h3>üìà Potential Swing Highs (Next 3-7 Days)</h3>`;
                if (predictions.swing_highs && predictions.swing_highs.length > 0) {
                    html += `<ul class="prediction-list">`;
                    predictions.swing_highs.forEach((sh, index) => {
                        html += `<li class="prediction-item">`;
                        html += `<strong>Level:</strong> ${formatPriceLevel(sh.level)} `;
                        html += `| <strong>Source:</strong> ${sh.source} `;
                        html += `| <strong>Score:</strong> ${sh.score}`;
                        html += `</li>`;
                    });
                    html += `</ul>`;
                } else {
                    html += `<p>No significant Swing High predictions at this time.</p>`;
                }
                html += `</div>`;

                html += `<div class="prediction-section">`;
                html += `<h3>üìâ Potential Swing Lows (Next 3-7 Days)</h3>`;
                if (predictions.swing_lows && predictions.swing_lows.length > 0) {
                    html += `<ul class="prediction-list">`;
                    predictions.swing_lows.forEach((sl, index) => {
                        html += `<li class="prediction-item">`;
                        html += `<strong>Level:</strong> ${formatPriceLevel(sl.level)} `;
                        html += `| <strong>Source:</strong> ${sl.source} `;
                        html += `| <strong>Score:</strong> ${sl.score}`;
                        html += `</li>`;
                    });
                    html += `</ul>`;
                } else {
                    html += `<p>No significant Swing Low predictions at this time.</p>`;
                }
                html += `</div>`;

                resultsDiv.innerHTML = `<div class="message success">${html}</div>`;
            } else {
                console.error("Unexpected API response:", data);
                showResult(`‚ùì Unexpected response structure from API.`, 'error');
            }
        }

        // --- UPDATED COUNTDOWN LOGIC ---
        async function startCountdown() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/next_run_time`);
                if (!response.ok) {
                    if (response.status === 429) {
                        // Don't show rate limit warning for countdown - it's less critical
                        return;
                    }
                    const errorData = await response.text();
                    throw new Error(`Failed to fetch next run time (${response.status}): ${errorData}`);
                }
                const data = await response.json();
                
                if (data.next_run_time_iso) {
                    const nextRunTime = new Date(data.next_run_time_iso);
                    updateCountdown(nextRunTime);
                    
                    if (countdownInterval) clearInterval(countdownInterval);
                    countdownInterval = setInterval(() => {
                        updateCountdown(nextRunTime);
                    }, 2500);
                } else {
                    document.getElementById('countdown').textContent = "Next Prediction Update: Not Scheduled";
                }
            } catch (error) {
                console.error("Failed to fetch next run time:", error);
                document.getElementById('countdown').textContent = `Next Prediction Update: Error - ${error.message.substring(0, 50)}...`;
            }
        }

        function updateCountdown(nextRunTime) {
            const now = new Date();
            const diff = nextRunTime - now;

            if (diff <= 0) {
                document.getElementById('countdown').textContent = "Next Prediction Update: In Progress or Just Finished...";
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                setTimeout(startCountdown, 30000); // Check again in 30 seconds
                return;
            }

            const totalSeconds = Math.floor(diff / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('countdown').textContent = `Next Prediction Update: ${formattedTime}`;
        }
        // --- END UPDATED COUNTDOWN LOGIC ---

    </script>

</body>
</html>