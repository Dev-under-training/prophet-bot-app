<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <title>P.R.O.P.H.E.T - Swing Predictor</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --bg-color: #ecf0f1;
            --text-color: #2c3e50;
            --border-color: #bdc3c7;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        /* --- Updated Header Style --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        h1 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.8em;
        }
        nav a {
            text-decoration: none;
            color: var(--secondary-color);
            font-weight: bold;
            margin-left: 15px;
        }
        nav a:hover {
            text-decoration: underline;
        }
        /* --- End Updated Header Style --- */

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        /* --- Styles for Auto-Suggest --- */
        .autocomplete {
            position: relative;
            flex-grow: 1;
            min-width: 200px;
        }
        #symbolInput {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
        }
        #symbolInput:focus {
            border-color: var(--secondary-color);
            outline: none;
        }
        .autocomplete-items {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 4px;
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
            display: none; /* Hidden by default */
        }
        .autocomplete-items div {
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border-bottom: 1px solid #d4d4d4;
        }
        .autocomplete-items div:hover {
            background-color: #e9e9e9;
        }
        .autocomplete-active {
            background-color: var(--secondary-color) !important;
            color: #ffffff;
        }
        /* --- END: Styles for Auto-Suggest --- */

        #predictButton {
            padding: 8px 15px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }
        #predictButton:hover:not(:disabled) {
            background-color: #2980b9;
        }
        #predictButton:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        /* --- Countdown Text --- */
        #countdown {
            font-weight: bold;
            color: var(--secondary-color);
            text-align: center;
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 4px;
            background-color: #e3f2fd;
        }
        /* --- END Countdown Text --- */
        #results {
            margin-top: 20px;
        }
        .message {
            padding: 15px;
            border-radius: 6px; /* Slightly rounder */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Subtle shadow */
            margin-bottom: 15px;
        }
        .loading {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        /* --- Enhanced Results Display --- */
        .prediction-results-container {
            /* Add padding if needed */
        }
        .prediction-section {
            margin-bottom: 25px; /* Slightly more space */
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 15px;
            background-color: #fafafa;
        }
        .prediction-section h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        .prediction-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .prediction-item {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: box-shadow 0.2s ease;
        }
        .prediction-item:hover {
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .prediction-main {
            margin-bottom: 8px;
        }
        .prediction-details {
            font-size: 0.9em;
            color: #555;
        }
        .no-predictions-message {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        /* --- Score Styling --- */
        .score-display {
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
        .score-desc {
            font-size: 0.85em;
            color: #666;
        }
        .score-very-high {
            background-color: #d4edda; /* Light green */
            color: #155724;
        }
        .score-high {
            background-color: #cce7ff; /* Light blue */
            color: #004085;
        }
        .score-medium {
            background-color: #fff3cd; /* Light yellow */
            color: #856404;
        }
        .score-low {
            background-color: #f8d7da; /* Light red */
            color: #721c24;
        }
        /* --- END Score Styling --- */

        .timestamp {
            font-size: 0.95em; /* Slightly larger */
            color: #495057; /* Slightly darker */
            margin-top: 8px;
            padding: 8px 12px;
            background-color: #e9ecef;
            border-radius: 4px;
            display: inline-block;
        }

        /* --- Enhanced Rate Limit Warning --- */
        .rate-limit-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: none;
            font-weight: bold;
            text-align: center;
        }

        /* --- Responsive Improvements --- */
        @media (max-width: 600px) {
            .container {
                padding: 15px; /* Less padding on small screens */
            }
            .controls {
                flex-direction: column; /* Stack controls on small screens */
                align-items: stretch;
            }
            #symbolInput, .autocomplete {
                width: 100%;
                margin-bottom: 10px;
            }
            #predictButton {
                width: 100%;
            }
            .prediction-item {
                padding: 12px;
            }
            .prediction-main, .prediction-details {
                font-size: 0.95em; /* Slightly smaller text */
            }
        }
        /* --- End UI/UX Enhancements CSS --- */
    </style>
</head>
<body>
    <div class="container">
        <!-- Updated Header with Navigation -->
        <header>
            <h1>üîÆ P.R.O.P.H.E.T - Market Swing Predictor</h1>
            <nav>
                <a href="index.html">Predictor</a>
                <a href="about.html">About</a>
            </nav>
        </header>

        <!-- Rate Limit Warning -->
        <div id="rateLimitWarning" class="rate-limit-warning">
            ‚ö†Ô∏è Rate limit exceeded. Please wait a moment before making another request.
        </div>

        <div class="controls">
            <!-- Auto-suggest input structure -->
            <div class="autocomplete">
                <input type="text" id="symbolInput" placeholder="Search for an asset (e.g., BTCUSDT)..." maxlength="20">
                <div id="symbolDropdown" class="autocomplete-items"></div>
            </div>
            <button id="predictButton" onclick="fetchPrediction()" disabled>Get Prediction</button>
        </div>

        <!-- Countdown Text -->
        <div id="countdown">Next Prediction Update: Loading...</div>

        <div id="results"></div>
    </div>

    <script>
        // --- Configuration ---
        const API_BASE_URL = ""; // Use relative path if served by FastAPI

        let symbolsList = [];
        let countdownInterval;
        let requestCount = 0;
        const MAX_REQUESTS_PER_MINUTE = 8; // Conservative limit
        const REQUEST_RESET_TIME = 60000; // 1 minute

        // --- Rate Limit Retry Logic for Countdown ---
        let countdownRetryAttempts = 0;
        const MAX_COUNTDOWN_RETRIES = 3;
        const COUNTDOWN_RETRY_DELAY = 30000; // 30 seconds

        // Reset request count every minute
        setInterval(() => {
            requestCount = 0;
        }, REQUEST_RESET_TIME);

        // --- Utility Functions ---
        function showResult(message, type = 'info') {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="message ${type}">${message}</div>`;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        function showRateLimitWarning(customMessage = null) {
            const warningDiv = document.getElementById('rateLimitWarning');
            const defaultMessage = '‚ö†Ô∏è Rate limit exceeded. Please wait a moment before making another request.';
            warningDiv.textContent = customMessage || defaultMessage;
            warningDiv.style.display = 'block';
            setTimeout(() => {
                warningDiv.style.display = 'none';
            }, 5000); // Hide after 5 seconds
        }

        // --- Auto-Suggest Functions ---
        function initAutocomplete() {
            const input = document.getElementById("symbolInput");
            const dropdown = document.getElementById("symbolDropdown");

            input.oninput = function() {
                const val = this.value.toUpperCase();
                closeAllLists();
                if (!val) { return false; }
                let matches = 0;
                symbolsList.forEach(symbol => {
                    if (symbol.toUpperCase().includes(val) && matches < 10) {
                        matches++;
                        const item = document.createElement("DIV");
                        item.innerHTML = `<strong>${symbol.substr(0, val.length)}</strong>${symbol.substr(val.length)}`;
                        item.innerHTML += `<input type='hidden' value='${symbol}'>`;
                        item.addEventListener("click", function(e) {
                            input.value = this.getElementsByTagName("input")[0].value;
                            closeAllLists();
                            document.getElementById('predictButton').disabled = false;
                        });
                        dropdown.appendChild(item);
                    }
                });
                if (matches > 0) {
                    dropdown.style.display = 'block';
                }
            };

            input.onkeydown = function(e) {
                let items = document.getElementById("symbolDropdown").getElementsByTagName("div");
                if (e.keyCode == 40) { // Down arrow
                    e.preventDefault();
                    currentFocus++;
                    addActive(items);
                } else if (e.keyCode == 38) { // Up arrow
                    e.preventDefault();
                    currentFocus--;
                    addActive(items);
                } else if (e.keyCode == 13) { // Enter
                    e.preventDefault();
                    if (currentFocus > -1 && items) {
                        items[currentFocus].click();
                    } else if (symbolsList.includes(input.value.toUpperCase())) {
                         document.getElementById('predictButton').disabled = false;
                         document.getElementById('predictButton').click();
                    }
                }
            };

            function addActive(items) {
                if (!items) return false;
                removeActive(items);
                if (currentFocus >= items.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = (items.length - 1);
                items[currentFocus].classList.add("autocomplete-active");
            }
            function removeActive(items) {
                for (let i = 0; i < items.length; i++) {
                    items[i].classList.remove("autocomplete-active");
                }
            }
            function closeAllLists(elmnt) {
                const items = document.getElementsByClassName("autocomplete-items");
                for (let i = 0; i < items.length; i++) {
                    if (elmnt != items[i] && elmnt != input) {
                        items[i].style.display = 'none';
                    }
                }
                currentFocus = -1;
            }
            document.addEventListener("click", function (e) {
                closeAllLists(e.target);
            });
        }
        let currentFocus = -1;
        // --- END: Auto-Suggest Functions ---

        // --- Main Functions ---
        window.onload = async function() {
            try {
                showResult('Loading available assets...', 'loading');
                const response = await fetch(`${API_BASE_URL}/api/symbols`);
                if (!response.ok) {
                    if (response.status === 429) {
                        showRateLimitWarning();
                        throw new Error('Too many requests. Please try again later.');
                    }
                    const errorData = await response.text();
                    throw new Error(`Failed to load symbols (${response.status}): ${errorData}`);
                }
                symbolsList = await response.json();
                initAutocomplete();
                document.getElementById('predictButton').disabled = false;
                clearResults();
            } catch (error) {
                console.error("Error loading symbols:", error);
                showResult(`‚ùå Error loading symbols: ${error.message}`, 'error');
            }
            startCountdown(); // Start countdown after symbols are loaded
        };

        async function fetchPrediction() {
            // Client-side rate limiting check
            if (requestCount >= MAX_REQUESTS_PER_MINUTE) {
                showRateLimitWarning(); // Use the improved warning
                return;
            }
            requestCount++;

            let symbol = document.getElementById('symbolInput').value.trim().toUpperCase();
            if (!symbol) {
                showResult('‚ö†Ô∏è Please enter or select an asset.', 'error');
                return;
            }

            const symbolRegex = /^[A-Z0-9]{3,20}$/;
            if (!symbolRegex.test(symbol)) {
                showResult('‚ö†Ô∏è Please enter a valid asset symbol (e.g., BTCUSDT). Must be 3-20 alphanumeric characters.', 'error');
                return;
            }

            showResult('üîç Fetching latest prediction...', 'loading');
            document.getElementById('predictButton').disabled = true;

            try {
                let response = await fetch(`${API_BASE_URL}/api/latest/${symbol}`);
                if (response.status === 404) {
                    showResult('‚öôÔ∏è Running market analysis (this may take 10-30 seconds)...', 'loading');
                    response = await fetch(`${API_BASE_URL}/api/predict/${symbol}`);
                }
                if (!response.ok) {
                    if (response.status === 429) {
                        // Specific handling for rate limit on prediction endpoints
                        showRateLimitWarning("‚ö†Ô∏è Too many prediction requests. Please wait before trying again.");
                        throw new Error('Too many requests. Please try again later.');
                    }
                    const errorData = await response.text();
                    throw new Error(`API request failed (${response.status}): ${errorData}`);
                }
                const data = await response.json();
                displayResults(data);
            } catch (error) {
                console.error("Prediction fetch error:", error);
                // Differentiate error messages based on error type if possible
                if (error.message.includes('Too many requests')) {
                     // Message already shown by showRateLimitWarning
                } else {
                     showResult(`‚ùå Error fetching prediction for ${symbol}: ${error.message}`, 'error');
                }
            } finally {
                document.getElementById('predictButton').disabled = false;
            }
        }

        // --- Enhanced Results Display ---
        function displayResults(data) {
            const resultsDiv = document.getElementById('results');

            // Helper function for formatting price levels
            const formatPriceLevel = function(price) {
                const numPrice = parseFloat(price);
                if (isNaN(numPrice)) return 'N/A';
                // Adjust decimal places based on asset? For now, keep your logic
                return numPrice.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 10,
                    useGrouping: false
                });
            };

            // Helper function for formatting scores
            const getScoreDescription = function(score) {
                if (score >= 10) return "Very High Confidence";
                if (score >= 8) return "High Confidence";
                if (score >= 6) return "Moderate Confidence";
                if (score >= 4) return "Lower Confidence";
                return "Low Confidence";
            };

            // Helper function for adding visual indicators to scores
            const getScoreClass = function(score) {
                if (score >= 10) return "score-very-high";
                if (score >= 8) return "score-high";
                if (score >= 6) return "score-medium";
                return "score-low";
            };

            if (data.status && (data.status.includes("success") || data.status.includes("cache"))) {
                const predictions = data.predictions;
                const symbol = data.symbol;

                let html = `<div class="prediction-results-container">`;
                html += `<h2>Predictions for ${symbol}</h2>`;
                if (predictions.timestamp_utc) {
                    const dateObj = new Date(predictions.timestamp_utc);
                    const formattedDate = dateObj.toLocaleString(undefined, {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        timeZoneName: 'short'
                    });
                    html += `<p class="timestamp"><strong>üïí Generated:</strong> ${formattedDate}</p>`;
                }

                // --- Swing Highs Section ---
                html += `<div class="prediction-section">`;
                html += `<h3>üìà Potential Swing Highs (Next 3-7 Days)</h3>`;
                if (predictions.swing_highs && predictions.swing_highs.length > 0) {
                    html += `<ul class="prediction-list">`;
                    // Sort by score descending for display
                    predictions.swing_highs
                        .sort((a, b) => b.score - a.score)
                        .forEach((sh, index) => {
                            html += `<li class="prediction-item">`;
                            html += `<div class="prediction-main">`;
                            html += `<strong>Level:</strong> ${formatPriceLevel(sh.level)} `;
                            html += `| <strong class="score-display ${getScoreClass(sh.score)}">Score:</strong> ${sh.score} <span class="score-desc">(${getScoreDescription(sh.score)})</span>`;
                            html += `</div>`;
                            html += `<div class="prediction-details">`;
                            html += `<strong>Source:</strong> ${sh.source}`;
                            html += `</div>`;
                            html += `</li>`;
                        });
                    html += `</ul>`;
                } else {
                    html += `<div class="no-predictions-message"><p>No significant Swing High predictions at this time.</p></div>`;
                }
                html += `</div>`; // End Swing Highs Section

                // --- Swing Lows Section ---
                html += `<div class="prediction-section">`;
                html += `<h3>üìâ Potential Swing Lows (Next 3-7 Days)</h3>`;
                if (predictions.swing_lows && predictions.swing_lows.length > 0) {
                    html += `<ul class="prediction-list">`;
                    // Sort by score descending for display
                    predictions.swing_lows
                        .sort((a, b) => b.score - a.score)
                        .forEach((sl, index) => {
                            html += `<li class="prediction-item">`;
                            html += `<div class="prediction-main">`;
                            html += `<strong>Level:</strong> ${formatPriceLevel(sl.level)} `;
                            html += `| <strong class="score-display ${getScoreClass(sl.score)}">Score:</strong> ${sl.score} <span class="score-desc">(${getScoreDescription(sl.score)})</span>`;
                            html += `</div>`;
                            html += `<div class="prediction-details">`;
                            html += `<strong>Source:</strong> ${sl.source}`;
                            html += `</div>`;
                            html += `</li>`;
                        });
                    html += `</ul>`;
                } else {
                    html += `<div class="no-predictions-message"><p>No significant Swing Low predictions at this time.</p></div>`;
                }
                html += `</div>`; // End Swing Lows Section

                html += `</div>`; // End container

                resultsDiv.innerHTML = `<div class="message success">${html}</div>`;
            } else {
                console.error("Unexpected API response:", data);
                showResult(`‚ùì Unexpected response structure from API.`, 'error');
            }
        }
        // --- END Enhanced Results Display ---

        // --- UPDATED COUNTDOWN LOGIC with Retry ---
        async function startCountdown() {
            // Prevent excessive retries on persistent errors
            if (countdownRetryAttempts > MAX_COUNTDOWN_RETRIES) {
                document.getElementById('countdown').textContent = "Next Prediction Update: Temporarily Unavailable";
                console.warn("Countdown update retries exhausted.");
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/next_run_time`);
                if (!response.ok) {
                    if (response.status === 429) {
                        // Server-side rate limit for countdown - this is expected if polling is too frequent
                        // Even though we adjusted the interval, bursts or server restarts can cause this
                        console.warn("Countdown endpoint rate limited. Retrying later.");
                        document.getElementById('countdown').textContent = "Next Prediction Update: Refreshing...";
                        countdownRetryAttempts++;
                        setTimeout(startCountdown, COUNTDOWN_RETRY_DELAY); // Retry after a longer delay
                        return; // Exit early, don't clear retry attempts yet
                    } else if (response.status >= 500) {
                        throw new Error(`Server error (${response.status})`);
                    } else {
                        const errorData = await response.text();
                        throw new Error(`Failed to fetch next run time (${response.status}): ${errorData}`);
                    }
                }
                // Reset retry attempts on successful fetch
                countdownRetryAttempts = 0;

                const data = await response.json();

                if (data.next_run_time_iso) {
                    const nextRunTime = new Date(data.next_run_time_iso);
                    updateCountdown(nextRunTime);

                    if (countdownInterval) clearInterval(countdownInterval);
                    // Poll every 2.5 seconds (as you already did)
                    countdownInterval = setInterval(() => {
                        updateCountdown(nextRunTime);
                    }, 2500);
                } else {
                    document.getElementById('countdown').textContent = "Next Prediction Update: Not Scheduled";
                }
            } catch (error) {
                console.error("Failed to fetch next run time:", error);
                countdownRetryAttempts++;
                document.getElementById('countdown').textContent = `Next Prediction Update: Error - Retrying...`;
                // Retry after a delay on error
                setTimeout(startCountdown, COUNTDOWN_RETRY_DELAY);
            }
        }

        function updateCountdown(nextRunTime) {
            const now = new Date();
            const diff = nextRunTime - now;

            if (diff <= 0) {
                document.getElementById('countdown').textContent = "Next Prediction Update: In Progress or Just Finished...";
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                setTimeout(startCountdown, 30000); // Check again in 30 seconds
                return;
            }

            const totalSeconds = Math.floor(diff / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('countdown').textContent = `Next Prediction Update: ${formattedTime}`;
        }
        // --- END UPDATED COUNTDOWN LOGIC ---

    </script>

</body>
</html>